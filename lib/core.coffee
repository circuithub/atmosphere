_s                     = require "underscore.string"
uuid                   = require "node-uuid"
bsync                  = require "bsync"
domain                 = require "domain"
types                  = require "./types"

Firebase               = require "firebase"
FirebaseTokenGenerator = require "firebase-token-generator"



########################################
## STATE MANAGEMENT
########################################

exports.init = (role, url, @serverToken, cbInitialized) =>
  console.log "\n\n\n=-=-=[core.init]", role, "\n\n\n" #xxx
  @firebaseServerURL = if url? then url else "https://atmosphere.firebaseio-demo.com/"  
  @setRole role
  @connect cbInitialized

exports.refs = () =>
  return @_ref

exports.initReferences = () =>
  @_ref = 
    rainDropsRef: new Firebase "#{@firebaseServerURL}atmosphere/rainDrops/"
    rainCloudsRef: new Firebase "#{@firebaseServerURL}atmosphere/rainClouds/"
    rainMakersRef: new Firebase "#{@firebaseServerURL}atmosphere/rainMakers/"

exports.urlLogSafe = @url

connectionReady = false

queues = {}
listeners = {}



########################################
## IDENTIFICATION
########################################

_rainID = uuid.v4() #Unique ID of this process/machine
_roleID = undefined

###
  ID of this machine
###
exports.rainID = () ->
  return if _roleID? then _roleID else _rainID

###
  Format machine prefix
###
exports.setRole = (role) ->
  _roleID = _s.humanize role
  _roleID = _roleID.replace " ", "_"
  _roleID = _s.truncate _roleID, 8
  _roleID = _s.truncate _roleID, 7 if _roleID[7] is "_"
  _roleID = _roleID.replace "...", ""
  _roleID = _roleID + "-" + _rainID
  return _roleID



########################################
## CONNECT
########################################

###
  Report whether the Job queueing system is ready for use
###
exports.ready = () ->
  return connectionReady

###
  Connect to specified Firebase
  -- Also handles re-connection and re-authentication (expired token)
  -- Connection is enforced, so if connection doesn't exist, nothing else will work.
###
exports.connect = (cbConnected) =>
  console.log "\n\n\n=-=-=[core.connect]", 1, "\n\n\n" #xxx
  if connectionReady
    #--Already connected
    cbConnected undefined
    return
  console.log "\n\n\n=-=-=[core.connect]", 2, @firebaseServerURL, "\n\n\n" #xxx
  dataRef = new Firebase @firebaseServerURL
  firebaseServerToken = @generateServerToken()
  if @firebaseServerURL.toLowerCase().indexOf("-demo") isnt -1 #Skip authenication if using Firebase demo mode
    console.log "[atmosphere]", "Running in demo mode (skipping authenication)"
    connectionReady = true
    @initReferences()
    cbConnected undefined
    return
  dataRef.auth firebaseServerToken, (error) =>
    if error?
      connectionReady = false
      if error.code is "EXPIRED_TOKEN"
        console.log "[firebaseAuthError]", "EXPIRED_TOKEN This should never happen..."
        #TODO: Reconnect on loss of authentication -- logic goes here
      else
        console.log "[firebaseAuthError]", "Login failed!", error
    else
      connectionReady = true 
      @initReferences()
      console.log "[atmosphere] Connected to Firebase!"      
  cbConnected error

###
  Generate Access Token for Server
  -- Full access! Be careful!
###
exports.generateServerToken = () =>
  return @serverToken



########################################
## DELETE
########################################

###
  Force delete of a queue (for maintainence/dev use)
###
exports.delete = (queueName) ->
  @rainDropsRef.child(queueName).remove()



########################################
## PUBLISH (SUBMIT)
########################################

###
  Publish (RabbitMQ terminology) a message to the specified queue
  -- Asynchronous, but callback is ignored
###
exports.publish = (queueName, messageObject, headerObject) ->
  rainDrop = 
    job: headerObject.job
    data: messageObject.data
    next: 
      callback: headerObject.callback
      callbackTo: headerObject.returnQueue         
      chain: messageObject.next
  # Generate a reference to a new location with push
  newRainDropRef = @_ref.rainDropsRef.child(queueName).push()
  # Set some data to the generated location
  newRainDropRef.set rainDrop, (error) ->
    if error?
      console.log "[atmosphere]", "Error occured during submit:", error, rainDrop
      return
  # Get the name generated by push (e.g. new job ID)
  return newRainDropRef.name()

###
  Submit a job
  -- Enforces job structure to make future refactor work safer  
###
exports.submit = types.fn (-> [ 
  @String()
  @Object {data: @Object(), next: @Array()}
  @Object {job: @Object({name: @String(), id: @String()}), returnQueue: @String(), callback: @Boolean()}
  ]),  
  (type, payload, headers) => 
    return exports.publish type, payload, headers

###
  Create the externally visible job key 
  -- Job chains must have unique external keys, even though this isn't enforced at present
###
exports.jobName = (job) ->
  return "#{job.type}-#{job.name}"

########################################
## SUBSCRIBE (LISTEN)
########################################



















########################################
## ACKNOWLEDGE
########################################

###
  Acknowledge the last job received of the specified type
  -- type: type of job you are ack'ing (you get only 1 job of any type at a time, but can subscribe to multiple types)
  -- cbAcknowledged: callback after ack is sent successfully
###
exports.acknowledge = (type, cbAcknowledged) =>
  if not connectionReady 
    cbAcknowledged console.log "noRabbitError", "Not connected to #{_urlLogSafe} yet!" 
    return
  if not queues[type]?
    cbAcknowledged "Connection to queue for job type #{type} not available! Are you listening to this queue?"
    return
  queues[type].shift()
  cbAcknowledged undefined

